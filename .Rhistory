popup = popup) %>%
addLegend(pal = pal,
values = df_merged$percent,
position = "bottomright",
title = "Percent of non U.S.<br>born citizens",
labFormat = labelFormat(suffix = "%"))
# Workaround for Leaflet bug with NA in legend
css_fix <- "div.info.legend.leaflet-control br {clear: both;}"
html_fix <- htmltools::tags$style(type = "text/css", css_fix)
RI %>% htmlwidgets::prependContent(html_fix)
htmlwidgets::saveWidget(frameableWidget(RI),'RI.html')
# Set popup labels
popup <- paste0("GEOID: ", df_merged$GEOID, "<br>", "Percent of non-U.S. Citizens: ", round(df_merged$percent,2))
# Set color palette
pal <- colorNumeric(
palette = "plasma",
domain = df_merged$percent
)
# Plot
RI<-leaflet(df_merged) %>%
addTiles() %>%
addPolygons(fillColor = ~pal(percent),
color = "#b2aeae",
fillOpacity = 0.7,
weight = 1,
smoothFactor = 0.2,
popup = popup) %>%
addLegend(pal = pal,
values = df_merged$percent,
position = "bottomright",
title = "Percent of non <br>U.S.-born citizens",
labFormat = labelFormat(suffix = "%"))
# Workaround for Leaflet bug with NA in legend
css_fix <- "div.info.legend.leaflet-control br {clear: both;}"
html_fix <- htmltools::tags$style(type = "text/css", css_fix)
RI %>% htmlwidgets::prependContent(html_fix)
htmlwidgets::saveWidget(frameableWidget(RI),'RI.html')
# Set popup labels
popup <- paste0("GEOID: ", df_merged$GEOID, "<br>", "Percent of non-U.S. Citizens: ", round(df_merged$percent,2))
# Set color palette
pal <- colorNumeric(
palette = "plasma",
domain = df_merged$percent
)
# Plot
RI<-leaflet(df_merged) %>%
addTiles() %>%
addPolygons(fillColor = ~pal(percent),
color = "#b2aeae",
fillOpacity = 0.7,
weight = 1,
smoothFactor = 0.2,
popup = popup) %>%
addLegend(pal = pal,
values = df_merged$percent,
position = "bottomright",
title = "Percent of non <br>US-born citizens",
labFormat = labelFormat(suffix = "%"))
# Workaround for Leaflet bug with NA in legend
css_fix <- "div.info.legend.leaflet-control br {clear: both;}"
html_fix <- htmltools::tags$style(type = "text/css", css_fix)
RI %>% htmlwidgets::prependContent(html_fix)
htmlwidgets::saveWidget(frameableWidget(RI),'RI.html')
htmlwidgets::saveWidget(frameableWidget(RI),'RI.html')
blogdown:::serve_site()
blogdown:::serve_site()
install.packages("cluster")
data(mtcars)
library(tidyverse)
library(cluster)
library(factoextra)
my_data <- mtcars %>%  scale()
head(my_data, n = 3)
res.dist <- get_dist(USArrests, stand = TRUE, method = "pearson")
fviz_dist(res.dist,
gradient = list(low = "#00AFBB", mid = "white", high = "#FC4E07"))
res.dist <- get_dist(mtcars, stand = TRUE, method = "pearson")
fviz_dist(res.dist,
gradient = list(low = "#00AFBB", mid = "white", high = "#FC4E07"))
fviz_nbclust(my_data, kmeans, method = "gap_stat")
set.seed(123)
km.res <- kmeans(my_data, 2, nstart = 25)
fviz_cluster(km.res, data = my_data,
ellipse.type = "convex",
palette = "jco",
ggtheme = theme_minimal())
res.hc <- mtcars %>%
scale() %>%                    # Scale the data
dist(method = "euclidean") %>% # Compute dissimilarity matrix
hclust(method = "ward.D2")     # Compute hierachical clustering
# Visualize using factoextra
# Cut in 4 groups and color by groups
fviz_dend(res.hc, k = 4, # Cut in four groups
cex = 0.5, # label size
k_colors = c("#2E9FDF", "#00AFBB", "#E7B800", "#FC4E07"),
color_labels_by_k = TRUE, # color labels by groups
rect = TRUE # Add rectangle around groups
)
install.packages("mlbench")
data(BostonHousing)
source('~/.active-rstudio-document', echo=TRUE)
library(help = "mlbench")
data(BostonHousing)
bh <- BostonHousing
head(bh)
my_data <- bh %>%  scale()
glimpse(bh)
View(bh$chas)
bh$chas<-as.numeric(bh$chas)
my_data <- bh %>%  scale()
fviz_nbclust(my_data, kmeans, method = "gap_stat")
res.hc <- bh %>%
scale() %>%                    # Scale the data
dist(method = "euclidean") %>% # Compute dissimilarity matrix
hclust(method = "ward.D2")     # Compute hierachical clustering
# Visualize using factoextra
# Cut in 4 groups and color by groups
fviz_dend(res.hc, k = 4, # Cut in four groups
cex = 0.5, # label size
k_colors = c("#2E9FDF", "#00AFBB", "#E7B800", "#FC4E07"),
color_labels_by_k = TRUE, # color labels by groups
rect = TRUE # Add rectangle around groups
)
set.seed(123)
km.res <- kmeans(my_data, 10, nstart = 25)
fviz_cluster(km.res, data = my_data,
ellipse.type = "convex",
palette = "jco",
ggtheme = theme_minimal())
data(Glass)
glass <- Glass
head(glass)
my_data <- glass %>%  scale()
head(my_data, n = 3)
glimpse(glass)
glass$Type<-as.numeric(glass$Type)
my_data <- glass %>%  scale()
head(my_data, n = 3)
fviz_nbclust(my_data, kmeans, method = "gap_stat")
set.seed(123)
km.res <- kmeans(my_data, 8, nstart = 25)
fviz_cluster(km.res, data = my_data,
ellipse.type = "convex",
palette = "jco",
ggtheme = theme_minimal())
res.hc <- glass %>%
scale() %>%                    # Scale the data
dist(method = "euclidean") %>% # Compute dissimilarity matrix
hclust(method = "ward.D2")     # Compute hierachical clustering
# Visualize using factoextra
# Cut in 4 groups and color by groups
fviz_dend(res.hc, k = 8, # Cut in four groups
cex = 0.5, # label size
k_colors = c("#2E9FDF", "#00AFBB", "#E7B800", "#FC4E07"),
color_labels_by_k = TRUE, # color labels by groups
rect = TRUE # Add rectangle around groups
)
res.hc <- glass %>%
scale() %>%                    # Scale the data
dist(method = "euclidean") %>% # Compute dissimilarity matrix
hclust(method = "ward.D2")     # Compute hierachical clustering
fviz_dend(res.hc, k = 8, # Cut in four groups
cex = 0.5, # label size
# k_colors = c("#2E9FDF", "#00AFBB", "#E7B800", "#FC4E07"),
color_labels_by_k = TRUE, # color labels by groups
rect = TRUE # Add rectangle around groups
)
fviz_dend(res.hc, k = 8, # Cut in four groups
cex = 0.5, # label size
# k_colors = c("#2E9FDF", "#00AFBB", "#E7B800", "#FC4E07"),
color_labels_by_k = TRUE, # color labels by groups
rect = TRUE # Add rectangle around groups
)
my_data <- glass %>%
select(Na:Fe) %>%
scale()
View(my_data)
glass <- Glass %>%
select(Na:Fe) %>%
scale()
head(my_data, n = 3)
fviz_nbclust(glass, kmeans, method = "gap_stat")
res.hc <- glass %>%
scale() %>%                    # Scale the data
dist(method = "euclidean") %>% # Compute dissimilarity matrix
hclust(method = "ward.D2")     # Compute hierachical clustering
# Visualize using factoextra
# Cut in 4 groups and color by groups
fviz_dend(res.hc, k = 8, # Cut in four groups
cex = 0.5, # label size
# k_colors = c("#2E9FDF", "#00AFBB", "#E7B800", "#FC4E07"),
color_labels_by_k = TRUE, # color labels by groups
rect = TRUE # Add rectangle around groups
)
set.seed(123)
km.res <- kmeans(glass, 8, nstart = 25)
fviz_cluster(km.res, data = my_data,
ellipse.type = "convex",
palette = "jco",
ggtheme = theme_minimal())
knitr::opts_chunk$set(echo = TRUE)
res.dist <- get_dist(glass, stand = TRUE, method = "pearson")
fviz_dist(res.dist,
gradient = list(low = "#00AFBB", mid = "white", high = "#FC4E07"))
res.dist <- get_dist(glass, stand = TRUE, method = "pearson")
fviz_dist(res.dist,
gradient = list(low = "#00AFBB", mid = "white", high = "#FC4E07"
))
fviz_nbclust(glass, FUNcluster, method = c("silhouette", "wss", "gap_stat"))
install.packages("NbClust")
library(NbClust)
fviz_nbclust(glass, FUNcluster, method = c("silhouette", "wss", "gap_stat"))
fviz_nbclust(glass, kmeans, method = c("silhouette", "wss", "gap_stat"))
fviz_nbclust(glass, kmeans, method = c("silhouette", "wss", "gap_stat"))
fviz_nbclust(glass, kmeans, method = "wss")
fviz_nbclust(glass, kmeans, method = "wss")
fviz_nbclust(glass, kmeans, method = "gap_stat")
set.seed(123)
km.res <- kmeans(glass, 8, nstart = 25)
fviz_cluster(km.res, data = my_data,
ellipse.type = "convex",
palette = "jco",
ggtheme = theme_minimal())
res.hc <- glass %>%
scale() %>%                    # Scale the data
dist(method = "euclidean") %>% # Compute dissimilarity matrix
hclust(method = "ward.D2")     # Compute hierachical clustering
fviz_dend(res.hc, k = 8, # Cut in four groups
cex = 0.5, # label size
# k_colors = c("#2E9FDF", "#00AFBB", "#E7B800", "#FC4E07"),
color_labels_by_k = TRUE, # color labels by groups
rect = TRUE # Add rectangle around groups
res.hc <- glass %>%
scale() %>%                    # Scale the data
dist(method = "centroid") %>% # Compute dissimilarity matrix
hclust(method = "ward.D2")     # Compute hierachical clustering
fviz_dend(res.hc, k = 8, # Cut in four groups
cex = 0.5, # label size
# k_colors = c("#2E9FDF", "#00AFBB", "#E7B800", "#FC4E07"),
color_labels_by_k = TRUE, # color labels by groups
rect = TRUE # Add rectangle around groups
)
install.packages("fpc")
update.packages(repos='http://cran.rstudio.com/', ask=FALSE, checkBuilt=TRUE)
install.packages(c("EpiModel", "igraph"))
library(devtools)
install_github("igraph/rigraph")
library(igraph)
uninstall.packages(igraph)
remove.packages(igraph)
library(igraph)
install.packages("fpc")
knitr::opts_chunk$set(echo = TRUE)
library(mlbench)
library(tidyverse)
library(cluster)
library(factoextra)
library(NbClust)
library(fpc)
# Load data
data(Glass)
head(Glass)
# Select only numeric variables and scale data
glass <- Glass %>%
select(Na:Fe) %>%
scale()
glass.nbclust <- glass %>%
NbClust(distance = "euclidean",
min.nc = 2, max.nc = 10,
method = "complete", index ="all")
fviz_nbclust(glass.nbclust, ggtheme = theme_minimal())
set.seed(123)
km10.res <- kmeans(glass, 10, nstart = 25)
km2.res <- kmeans(glass, 2, nstart = 25)
fviz_cluster(km10.res, data = glass,
# ellipse = FALSE,
ellipse.type = "norm",
palette = "jco",
ggtheme = theme_minimal())
fviz_cluster(km2.res, data = glass,
# ellipse = FALSE,
ellipse.type = "norm",
palette = "jco",
ggtheme = theme_minimal())
km_stats <- cluster.stats(dist(glass),  km.res10$cluster)
km_stats <- cluster.stats(dist(glass),  km10.res$cluster)
km_stats <- cluster.stats(dist(glass),  km10.res$cluster)
km_stats$dunn
?cluster.stats()
km_stats
# Load data
data(Glass)
head(Glass)
# Select only numeric variables and scale data
glass <- Glass %>%
select(Na:Fe) %>%
scale()
table(Glass$Type, km.res2$cluster)
table(Glass$Type, km2.res$cluster)
table(Glass$Type, km10.res$cluster)
type <- as.numeric(Glass$Type)
clust_stats <- cluster.stats(d = dist(df),
type, km.res10$cluster)
clust_stats$corrected.rand
clust_stats <- cluster.stats(d = dist(glass),
type, km.res10$cluster)
clust_stats <- cluster.stats(d = dist(glass),
type, km10.res$cluster)
clust_stats$corrected.rand
km7.res <- kmeans(glass, 7, nstart = 25)
clust_stats <- cluster.stats(d = dist(glass),
type, km7.res$cluster)
clust_stats$corrected.rand
clust_stats <- cluster.stats(d = dist(glass),
type, km2.res$cluster)
clust_stats$corrected.rand
table(Glass$Type, km7.res$cluster)
km_stats <- cluster.stats(dist(glass),  km10.res$cluster)
km_stats$dunn
# Load data
data(Glass)
head(Glass)
# Select only numeric variables and scale data
glass <- Glass %>%
select(Na:Fe) %>%
scale()
type <- as.numeric(Glass$Type)
clust_stats <- cluster.stats(d = dist(glass),
type, km10.res$cluster)
clust_stats$corrected.rand
?set.seed
knitr::opts_chunk$set(echo = TRUE)
fviz_silhouette(km2.res)
---
title: "k-Means Clustering"
draft: false
toc: true
toc_float: true
type: docs
linktitle: k-Means Clustering
menu:
docs:
parent: Machine Learning
weight: 1
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## Overview
When attempting to cluster multivariate data, degrees of similarity and dissimilarity between observtions are calculated using [distance measurements](https://www.datanovia.com/en/lessons/clustering-distance-measures/) dependent on the nature of the data and statistical objectives. One of the most popular partitioning clustering methods, [*k*-means](https://en.wikipedia.org/wiki/K-means_clustering), uses the mean values of data points to forumlate clusters. The `factoextra` package allows for quick and easy *k*-means clustering visualization, while `NbClust` and `fpc` allow us to identify the number of clusters in our data and validate results.
```{r, message=FALSE}
library(mlbench)
library(tidyverse)
library(cluster)
library(factoextra)
library(NbClust)
library(fpc)
```
For this exercise we'll be using the multivariate [Glass Identification](https://archive.ics.uci.edu/ml/datasets/Glass+Identification) dataset from the UCI machine learning repository, which documents the compostion of 214 samples classified by 10 variables.
```{r}
# Load data
data(Glass)
head(Glass)
# Select only numeric variables and scale data
glass <- Glass %>%
select(Na:Fe) %>%
scale()
```
## Determining Optimal Number of Clusters
In order to decide how many clusters to display, we can use the `NbClust` function to cycle through a variety of different tests avialable in `r` including the elbow method, silhouette method and the gap statistic option among [many others](https://www.rdocumentation.org/packages/NbClust/versions/3.0/topics/NbClust). The specific details of the different clustering algorithms is beyond the scope of our exercise today, but for further information refer to `NbClust`'s associated article in the [Journal of Statistical Software](https://www.jstatsoft.org/index.php/jss/article/view/v061i06/v61i06.pdf). In essence, selecting the "correct" number of centroids is dependent on domain knowledge, specific statistical considerations based on the data itself, and whether you're looking for [knowledge or data-driven results](https://stats.stackexchange.com/questions/23472/how-to-decide-on-the-correct-number-of-clusters):
```{r, results='hide', fig.show='hide'}
glass.nbclust <- glass %>%
NbClust(distance = "euclidean",
min.nc = 2, max.nc = 10,
method = "complete", index ="all")
```
```{r}
fviz_nbclust(glass.nbclust, ggtheme = theme_minimal())
```
Since our tutorial assumes no background in compositional analysis, for this example we'll proceed using both *k*=10 as suggested above as well as *k*=2 to compare the results. We can then insert these values into our `fviz_cluster` calls to plot the clusters:
```{r}
# Randomize
set.seed(123)
# Calculate k-means clusters
km10.res <- kmeans(glass, 10, nstart = 25)
km2.res <- kmeans(glass, 2, nstart = 25)
# Plot k=2
fviz_cluster(km2.res, data = glass,
# ellipse = FALSE,
ellipse.type = "norm",
palette = "jco",
ggtheme = theme_minimal())
# Plot k=10
fviz_cluster(km10.res, data = glass,
# ellipse = FALSE,
ellipse.type = "norm",
palette = "jco",
ggtheme = theme_minimal())
```
Depending on our research questions, either *k*=2 or *k*=10 could prove useful; each allows a different visualization of the data and highlights different trends. If we're exploring minute variations in composition based on barium content, the complex plot of *k*=10 may better elucidate chemical relationships for our purposes. However, if we want to simply see broad trends in the data, *k*=2 may be better suited for cursory evaluation.
## Assessing Clustering Quality
Silhouette
```{r}
fviz_silhouette(km2.res)
fviz_silhouette(km10.res)
```
Cluster validation can be calculated quantitatively using metrics like the [Dunn index](https://en.wikipedia.org/wiki/Dunn_index), which is an internal evaluation method that aims to identify compact clusters on a scale of -1 (poor clustering) to 1 (good clustering):
```{r}
km_stats <- cluster.stats(dist(glass), km10.res$cluster)
km_stats$dunn
```
We can also use the corrected [Rand index](https://en.wikipedia.org/wiki/Rand_index) to see how our clusters match up to known groups (if present in the dataset). In our case, this could be tested against the `Type` variable from the original `Glass` dataframe. Like the Dunn index, a range from -1 to 1 is expected for the test:
```{r}
type <- as.numeric(Glass$Type)
clust_stats <- cluster.stats(d = dist(glass),
type, km10.res$cluster)
clust_stats$corrected.rand
```
## Final Thoughts
GLGLGLGASDFFGAFGADFDSs
fviz_silhouette(km2.res)
# Calcluate silhouettes from k-means
sil_2 <- silhouette(km2.res$cluster, dist(glass))
sil_10 <- silhouette(km10.res$cluster, dist(glass))
# Plot silhouettes
fviz_silhouette(sil_2)
fviz_silhouette(sil_10)
?fviz_silhouette
# Calcluate silhouettes from k-means
sil_2 <- silhouette(km2.res$cluster, dist(glass))
sil_10 <- silhouette(km10.res$cluster, dist(glass))
# Plot silhouettes
fviz_silhouette(sil_2, print.summary = FALSE)
fviz_silhouette(sil_10, print.summary = FALSE)
# Calcluate silhouettes from k-means
sil_2 <- silhouette(km2.res$cluster, dist(glass))
sil_10 <- silhouette(km10.res$cluster, dist(glass))
# Plot silhouettes
fviz_silhouette(sil_2)
fviz_silhouette(sil_10)
fviz_nbclust(glass.nbclust)
fviz_pca_ind(prcomp(glass), title = "PCA - Random data",
geom = "point", ggtheme = theme_classic())
fviz_pca_ind(prcomp(glass),
habillage = Glass$Type,  palette = "jco",
geom = "point", ggtheme = theme_classic(),
legend = "bottom")
# fviz_pca_ind(prcomp(glass),
#              habillage = Glass$Type,  palette = "jco",
#              geom = "point", ggtheme = theme_classic(),
#              legend = "bottom")
res <- get_clust_tendency(glass, n = nrow(df)-1, graph = FALSE)
res$hopkins_stat
# fviz_pca_ind(prcomp(glass),
#              habillage = Glass$Type,  palette = "jco",
#              geom = "point", ggtheme = theme_classic(),
#              legend = "bottom")
res <- get_clust_tendency(glass, n = nrow(df)-1, graph = FALSE)
res$hopkins_stat
gradient.color <- list(low = "steelblue",  high = "white")
glass %>%    # Remove column 5 (Species)
scale() %>%     # Scale variables
get_clust_tendency(n = 50, gradient = gradient.color)
# fviz_pca_ind(prcomp(glass),
#              habillage = Glass$Type,  palette = "jco",
#              geom = "point", ggtheme = theme_classic(),
#              legend = "bottom")
res <- get_clust_tendency(glass, n = nrow(df)-1, graph = FALSE)
res$hopkins_stat
gradient.color <- list(low = "steelblue",  high = "white")
glass %>%    # Remove column 5 (Species)
scale() %>%     # Scale variables
get_clust_tendency(n = 50)
res <- get_clust_tendency(glass, n = nrow(df)-1, graph = TRUE)
res$hopkins_stat
res <- get_clust_tendency(glass, n = nrow(df)-1, graph = FALSE)
res$hopkins_stat
res <- get_clust_tendency(glass, n = nrow(glass)-1, graph = FALSE)
res$hopkins_stat
# Calcluate silhouettes from k-means
sil_2 <- silhouette(km2.res$cluster, dist(glass))
sil_10 <- silhouette(km10.res$cluster, dist(glass))
# Plot silhouettes
fviz_silhouette(sil_2)
fviz_silhouette(sil_10)
km_stats <- cluster.stats(dist(glass), km10.res$cluster)
km_stats$dunn
type <- as.numeric(Glass$Type)
clust_stats <- cluster.stats(d = dist(glass),
type, km10.res$cluster)
clust_stats$corrected.rand
blogdown:::serve_site()
blogdown:::serve_site()
library(mlbench)
library(tidyverse)
library(cluster)
library(factoextra)
library(NbClust)
library(fpc)
blogdown:::serve_site()
# Load data
data(Glass)
head(Glass)
# Select only numeric variables and scale data
glass <- Glass %>%
select(Na:Fe) %>%
scale()
library(tidyverse)
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::build_site()
