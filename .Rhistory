# Set color palette
pal <- colorNumeric(
palette = "plasma",
domain = df_merged$percent
)
RI<-leaflet() %>%
addProviderTiles("CartoDB.Positron") %>%
addPolygons(data = df_merged,
fillColor = ~pal(percent),
color = "#b2aeae", # you need to use hex colors
fillOpacity = 0.7,
weight = 1,
smoothFactor = 0.2,
popup = popup) %>%
addLegend(pal = pal,
values = df_merged$percent,
position = "bottomright",
title = "Percent of non-U.S.<br>Citizens",
labFormat = labelFormat(suffix = "%"))
htmlwidgets::saveWidget(frameableWidget(RI),'RI.html')
library(tidyverse)
library(tigris)
library(acs)
library(leaflet)
library(htmltools)
library(widgetframe)
# Set popup labels
popup <- paste0("GEOID: ", df_merged$GEOID, "<br>", "Percent of non-U.S. Citizens: ", round(df_merged$percent,2))
# Set color palette
pal <- colorNumeric(
palette = "plasma",
domain = df_merged$percent
)
RI<-leaflet() %>%
addProviderTiles("CartoDB.Positron") %>%
addPolygons(data = df_merged,
fillColor = ~pal(percent),
color = "#b2aeae", # you need to use hex colors
fillOpacity = 0.7,
weight = 1,
smoothFactor = 0.2,
popup = popup) %>%
addLegend(pal = pal,
values = df_merged$percent,
position = "bottomright",
title = "Percent of non-U.S.<br>Citizens",
labFormat = labelFormat(suffix = "%"))
htmlwidgets::saveWidget(frameableWidget(RI),'RI.html')
# Select Rhode Island for tracts
tracts <- tracts(state = 'RI', cb=TRUE)
# Fetch ACS data
ri <- acs.fetch(
geography = geo.make(state = "RI", county="*", tract = "*"),
endyear = 2011, span = 5,
table.number = "B05001",
col.names = "pretty")
# View column names
attr(ri, "acs.colnames")
# Create new dataframe including geolocation data and estimates
ri_df <- data.frame(
paste0(
str_pad(ri@geography$state,  2, "left", pad="0"),
str_pad(ri@geography$county, 3, "left", pad="0"),
str_pad(ri@geography$tract,  6, "left", pad="0")),
ri@estimate[,c("Nativity and Citizenship Status in the United States: Total:", "Nativity and Citizenship Status in the United States: Not a U.S. citizen")],
stringsAsFactors = FALSE)
# Select subset of initial dataframe
ri_df <- dplyr::select(ri_df, 1:3) %>% tbl_df()
# Rename rows
names(ri_df) <- c("GEOID", "total", "non_citizen")
# Calculate percentage of non-U.S. citizens
ri_df$percent <- 100*(ri_df$non_citizen/ri_df$total)
# Spatial join
df_merged <- geo_join(tracts, ri_df, "GEOID", "GEOID")
# Remove any tracts with no land area
df_merged <- df_merged[df_merged$ALAND>0,]
# Set popup labels
popup <- paste0("GEOID: ", df_merged$GEOID, "<br>", "Percent of non-U.S. Citizens: ", round(df_merged$percent,2))
# Set color palette
pal <- colorNumeric(
palette = "plasma",
domain = df_merged$percent
)
RI<-leaflet() %>%
addProviderTiles("CartoDB.Positron") %>%
addPolygons(data = df_merged,
fillColor = ~pal(percent),
color = "#b2aeae", # you need to use hex colors
fillOpacity = 0.7,
weight = 1,
smoothFactor = 0.2,
popup = popup) %>%
addLegend(pal = pal,
values = df_merged$percent,
position = "bottomright",
title = "Percent of non-U.S.<br>Citizens",
labFormat = labelFormat(suffix = "%"))
htmlwidgets::saveWidget(frameableWidget(RI),'RI.html')
leaflet(df_merged) %>%
addTiles() %>%
addPolygons(fillColor = ~pal(percent),
color = "#b2aeae",
fillOpacity = 0.7,
weight = 1,
smoothFactor = 0.2,
popup = popup)
l2<-leaflet(test2) %>%
addTiles() %>%
addAwesomeMarkers(~lon, ~lat, popup = ~Salary,
icon = awesomeIcons(icon = 'ion-ionic',
library = 'ion',
markerColor = test2$Color_code),
label = lapply(labs, htmltools::HTML),
labelOptions = labelOptions(textsize = "15px",
style=list(
'background'='rgba(243, 241, 239, 1)',
'border-color' = 'rgba(46, 49, 49, 1)',
'border-radius' = '2px',
'border-style' = 'solid',
'border-width' = '2px'))) %>%
addLegend("bottomright",
colors =c("#70AF28",  "#38ADDF", "	#F79530", "#CC3E24", "#575556"),
labels= c("Over £40,000","£30,000 - £39,999","£20,000 - £29,999","Below £20,000","Rate Unavailable"),
title= "Salary",
opacity = 1)
htmlwidgets::saveWidget(frameableWidget(l2),'leafletscrape.html')
# Select Rhode Island for tracts
tracts <- tracts(state = 'RI', cb=TRUE)
# Fetch ACS data
ri <- acs.fetch(
geography = geo.make(state = "RI", county="*", tract = "*"),
endyear = 2011, span = 5,
table.number = "B05001",
col.names = "pretty")
# View column names
attr(ri, "acs.colnames")
css_fix <- "div.info.legend.leaflet-control br {clear: both;}"
html_fix <- htmltools::tags$style(type = "text/css", css_fix)
RI %<>% htmlwidgets::prependContent(html_fix)
RI %>% htmlwidgets::prependContent(html_fix)
blogdown:::serve_site()
# Set popup labels
popup <- paste0("GEOID: ", df_merged$GEOID, "<br>", "Percent of non-U.S. Citizens: ", round(df_merged$percent,2))
# Set color palette
pal <- colorNumeric(
palette = "plasma",
domain = df_merged$percent
)
# Plot
RI<-leaflet(df_merged) %>%
addTiles() %>%
addPolygons(fillColor = ~pal(percent),
color = "#b2aeae",
fillOpacity = 0.7,
weight = 1,
smoothFactor = 0.2,
popup = popup) %>%
addLegend(pal = pal,
values = df_merged$percent,
position = "bottomright",
title = "Percent of non-U.S.<br>Citizens",
labFormat = labelFormat(suffix = "%"))
# Workaround for Leaflet bug with NA in legend
css_fix <- "div.info.legend.leaflet-control br {clear: both;}"
html_fix <- htmltools::tags$style(type = "text/css", css_fix)
RI %>% htmlwidgets::prependContent(html_fix)
htmlwidgets::saveWidget(frameableWidget(RI),'RI.html')
# Set popup labels
popup <- paste0("GEOID: ", df_merged$GEOID, "<br>", "Percent of non-U.S. Citizens: ", round(df_merged$percent,2))
# Set color palette
pal <- colorNumeric(
palette = "plasma",
domain = df_merged$percent
)
# Plot
RI<-leaflet(df_merged) %>%
addTiles() %>%
addPolygons(fillColor = ~pal(percent),
color = "#b2aeae",
fillOpacity = 0.7,
weight = 1,
smoothFactor = 0.2,
popup = popup) %>%
addLegend(pal = pal,
values = df_merged$percent,
position = "bottomright",
title = "Percent of non U.S.<br>born citizens",
labFormat = labelFormat(suffix = "%"))
# Workaround for Leaflet bug with NA in legend
css_fix <- "div.info.legend.leaflet-control br {clear: both;}"
html_fix <- htmltools::tags$style(type = "text/css", css_fix)
RI %>% htmlwidgets::prependContent(html_fix)
htmlwidgets::saveWidget(frameableWidget(RI),'RI.html')
# Set popup labels
popup <- paste0("GEOID: ", df_merged$GEOID, "<br>", "Percent of non-U.S. Citizens: ", round(df_merged$percent,2))
# Set color palette
pal <- colorNumeric(
palette = "plasma",
domain = df_merged$percent
)
# Plot
RI<-leaflet(df_merged) %>%
addTiles() %>%
addPolygons(fillColor = ~pal(percent),
color = "#b2aeae",
fillOpacity = 0.7,
weight = 1,
smoothFactor = 0.2,
popup = popup) %>%
addLegend(pal = pal,
values = df_merged$percent,
position = "bottomright",
title = "Percent of non <br>U.S.-born citizens",
labFormat = labelFormat(suffix = "%"))
# Workaround for Leaflet bug with NA in legend
css_fix <- "div.info.legend.leaflet-control br {clear: both;}"
html_fix <- htmltools::tags$style(type = "text/css", css_fix)
RI %>% htmlwidgets::prependContent(html_fix)
htmlwidgets::saveWidget(frameableWidget(RI),'RI.html')
# Set popup labels
popup <- paste0("GEOID: ", df_merged$GEOID, "<br>", "Percent of non-U.S. Citizens: ", round(df_merged$percent,2))
# Set color palette
pal <- colorNumeric(
palette = "plasma",
domain = df_merged$percent
)
# Plot
RI<-leaflet(df_merged) %>%
addTiles() %>%
addPolygons(fillColor = ~pal(percent),
color = "#b2aeae",
fillOpacity = 0.7,
weight = 1,
smoothFactor = 0.2,
popup = popup) %>%
addLegend(pal = pal,
values = df_merged$percent,
position = "bottomright",
title = "Percent of non <br>US-born citizens",
labFormat = labelFormat(suffix = "%"))
# Workaround for Leaflet bug with NA in legend
css_fix <- "div.info.legend.leaflet-control br {clear: both;}"
html_fix <- htmltools::tags$style(type = "text/css", css_fix)
RI %>% htmlwidgets::prependContent(html_fix)
htmlwidgets::saveWidget(frameableWidget(RI),'RI.html')
htmlwidgets::saveWidget(frameableWidget(RI),'RI.html')
blogdown:::serve_site()
blogdown:::serve_site()
install.packages("cluster")
data(mtcars)
library(tidyverse)
library(cluster)
library(factoextra)
my_data <- mtcars %>%  scale()
head(my_data, n = 3)
res.dist <- get_dist(USArrests, stand = TRUE, method = "pearson")
fviz_dist(res.dist,
gradient = list(low = "#00AFBB", mid = "white", high = "#FC4E07"))
res.dist <- get_dist(mtcars, stand = TRUE, method = "pearson")
fviz_dist(res.dist,
gradient = list(low = "#00AFBB", mid = "white", high = "#FC4E07"))
fviz_nbclust(my_data, kmeans, method = "gap_stat")
set.seed(123)
km.res <- kmeans(my_data, 2, nstart = 25)
fviz_cluster(km.res, data = my_data,
ellipse.type = "convex",
palette = "jco",
ggtheme = theme_minimal())
res.hc <- mtcars %>%
scale() %>%                    # Scale the data
dist(method = "euclidean") %>% # Compute dissimilarity matrix
hclust(method = "ward.D2")     # Compute hierachical clustering
# Visualize using factoextra
# Cut in 4 groups and color by groups
fviz_dend(res.hc, k = 4, # Cut in four groups
cex = 0.5, # label size
k_colors = c("#2E9FDF", "#00AFBB", "#E7B800", "#FC4E07"),
color_labels_by_k = TRUE, # color labels by groups
rect = TRUE # Add rectangle around groups
)
install.packages("mlbench")
data(BostonHousing)
source('~/.active-rstudio-document', echo=TRUE)
library(help = "mlbench")
data(BostonHousing)
bh <- BostonHousing
head(bh)
my_data <- bh %>%  scale()
glimpse(bh)
View(bh$chas)
bh$chas<-as.numeric(bh$chas)
my_data <- bh %>%  scale()
fviz_nbclust(my_data, kmeans, method = "gap_stat")
res.hc <- bh %>%
scale() %>%                    # Scale the data
dist(method = "euclidean") %>% # Compute dissimilarity matrix
hclust(method = "ward.D2")     # Compute hierachical clustering
# Visualize using factoextra
# Cut in 4 groups and color by groups
fviz_dend(res.hc, k = 4, # Cut in four groups
cex = 0.5, # label size
k_colors = c("#2E9FDF", "#00AFBB", "#E7B800", "#FC4E07"),
color_labels_by_k = TRUE, # color labels by groups
rect = TRUE # Add rectangle around groups
)
set.seed(123)
km.res <- kmeans(my_data, 10, nstart = 25)
fviz_cluster(km.res, data = my_data,
ellipse.type = "convex",
palette = "jco",
ggtheme = theme_minimal())
data(Glass)
glass <- Glass
head(glass)
my_data <- glass %>%  scale()
head(my_data, n = 3)
glimpse(glass)
glass$Type<-as.numeric(glass$Type)
my_data <- glass %>%  scale()
head(my_data, n = 3)
fviz_nbclust(my_data, kmeans, method = "gap_stat")
set.seed(123)
km.res <- kmeans(my_data, 8, nstart = 25)
fviz_cluster(km.res, data = my_data,
ellipse.type = "convex",
palette = "jco",
ggtheme = theme_minimal())
res.hc <- glass %>%
scale() %>%                    # Scale the data
dist(method = "euclidean") %>% # Compute dissimilarity matrix
hclust(method = "ward.D2")     # Compute hierachical clustering
# Visualize using factoextra
# Cut in 4 groups and color by groups
fviz_dend(res.hc, k = 8, # Cut in four groups
cex = 0.5, # label size
k_colors = c("#2E9FDF", "#00AFBB", "#E7B800", "#FC4E07"),
color_labels_by_k = TRUE, # color labels by groups
rect = TRUE # Add rectangle around groups
)
res.hc <- glass %>%
scale() %>%                    # Scale the data
dist(method = "euclidean") %>% # Compute dissimilarity matrix
hclust(method = "ward.D2")     # Compute hierachical clustering
fviz_dend(res.hc, k = 8, # Cut in four groups
cex = 0.5, # label size
# k_colors = c("#2E9FDF", "#00AFBB", "#E7B800", "#FC4E07"),
color_labels_by_k = TRUE, # color labels by groups
rect = TRUE # Add rectangle around groups
)
fviz_dend(res.hc, k = 8, # Cut in four groups
cex = 0.5, # label size
# k_colors = c("#2E9FDF", "#00AFBB", "#E7B800", "#FC4E07"),
color_labels_by_k = TRUE, # color labels by groups
rect = TRUE # Add rectangle around groups
)
my_data <- glass %>%
select(Na:Fe) %>%
scale()
View(my_data)
glass <- Glass %>%
select(Na:Fe) %>%
scale()
head(my_data, n = 3)
fviz_nbclust(glass, kmeans, method = "gap_stat")
res.hc <- glass %>%
scale() %>%                    # Scale the data
dist(method = "euclidean") %>% # Compute dissimilarity matrix
hclust(method = "ward.D2")     # Compute hierachical clustering
# Visualize using factoextra
# Cut in 4 groups and color by groups
fviz_dend(res.hc, k = 8, # Cut in four groups
cex = 0.5, # label size
# k_colors = c("#2E9FDF", "#00AFBB", "#E7B800", "#FC4E07"),
color_labels_by_k = TRUE, # color labels by groups
rect = TRUE # Add rectangle around groups
)
set.seed(123)
km.res <- kmeans(glass, 8, nstart = 25)
fviz_cluster(km.res, data = my_data,
ellipse.type = "convex",
palette = "jco",
ggtheme = theme_minimal())
knitr::opts_chunk$set(echo = TRUE)
res.dist <- get_dist(glass, stand = TRUE, method = "pearson")
fviz_dist(res.dist,
gradient = list(low = "#00AFBB", mid = "white", high = "#FC4E07"))
res.dist <- get_dist(glass, stand = TRUE, method = "pearson")
fviz_dist(res.dist,
gradient = list(low = "#00AFBB", mid = "white", high = "#FC4E07"
))
fviz_nbclust(glass, FUNcluster, method = c("silhouette", "wss", "gap_stat"))
install.packages("NbClust")
library(NbClust)
fviz_nbclust(glass, FUNcluster, method = c("silhouette", "wss", "gap_stat"))
fviz_nbclust(glass, kmeans, method = c("silhouette", "wss", "gap_stat"))
fviz_nbclust(glass, kmeans, method = c("silhouette", "wss", "gap_stat"))
fviz_nbclust(glass, kmeans, method = "wss")
fviz_nbclust(glass, kmeans, method = "wss")
fviz_nbclust(glass, kmeans, method = "gap_stat")
set.seed(123)
km.res <- kmeans(glass, 8, nstart = 25)
fviz_cluster(km.res, data = my_data,
ellipse.type = "convex",
palette = "jco",
ggtheme = theme_minimal())
res.hc <- glass %>%
scale() %>%                    # Scale the data
dist(method = "euclidean") %>% # Compute dissimilarity matrix
hclust(method = "ward.D2")     # Compute hierachical clustering
fviz_dend(res.hc, k = 8, # Cut in four groups
cex = 0.5, # label size
# k_colors = c("#2E9FDF", "#00AFBB", "#E7B800", "#FC4E07"),
color_labels_by_k = TRUE, # color labels by groups
rect = TRUE # Add rectangle around groups
res.hc <- glass %>%
scale() %>%                    # Scale the data
dist(method = "centroid") %>% # Compute dissimilarity matrix
hclust(method = "ward.D2")     # Compute hierachical clustering
fviz_dend(res.hc, k = 8, # Cut in four groups
cex = 0.5, # label size
# k_colors = c("#2E9FDF", "#00AFBB", "#E7B800", "#FC4E07"),
color_labels_by_k = TRUE, # color labels by groups
rect = TRUE # Add rectangle around groups
)
install.packages("fpc")
update.packages(repos='http://cran.rstudio.com/', ask=FALSE, checkBuilt=TRUE)
install.packages(c("EpiModel", "igraph"))
library(devtools)
install_github("igraph/rigraph")
library(igraph)
uninstall.packages(igraph)
remove.packages(igraph)
library(igraph)
install.packages("fpc")
knitr::opts_chunk$set(echo = TRUE)
library(mlbench)
library(tidyverse)
library(cluster)
library(factoextra)
library(NbClust)
library(fpc)
# Load data
data(Glass)
head(Glass)
# Select only numeric variables and scale data
glass <- Glass %>%
select(Na:Fe) %>%
scale()
glass.nbclust <- glass %>%
NbClust(distance = "euclidean",
min.nc = 2, max.nc = 10,
method = "complete", index ="all")
fviz_nbclust(glass.nbclust, ggtheme = theme_minimal())
set.seed(123)
km10.res <- kmeans(glass, 10, nstart = 25)
km2.res <- kmeans(glass, 2, nstart = 25)
fviz_cluster(km10.res, data = glass,
# ellipse = FALSE,
ellipse.type = "norm",
palette = "jco",
ggtheme = theme_minimal())
fviz_cluster(km2.res, data = glass,
# ellipse = FALSE,
ellipse.type = "norm",
palette = "jco",
ggtheme = theme_minimal())
km_stats <- cluster.stats(dist(glass),  km.res10$cluster)
km_stats <- cluster.stats(dist(glass),  km10.res$cluster)
km_stats <- cluster.stats(dist(glass),  km10.res$cluster)
km_stats$dunn
?cluster.stats()
km_stats
# Load data
data(Glass)
head(Glass)
# Select only numeric variables and scale data
glass <- Glass %>%
select(Na:Fe) %>%
scale()
table(Glass$Type, km.res2$cluster)
table(Glass$Type, km2.res$cluster)
table(Glass$Type, km10.res$cluster)
type <- as.numeric(Glass$Type)
clust_stats <- cluster.stats(d = dist(df),
type, km.res10$cluster)
clust_stats$corrected.rand
clust_stats <- cluster.stats(d = dist(glass),
type, km.res10$cluster)
clust_stats <- cluster.stats(d = dist(glass),
type, km10.res$cluster)
clust_stats$corrected.rand
km7.res <- kmeans(glass, 7, nstart = 25)
clust_stats <- cluster.stats(d = dist(glass),
type, km7.res$cluster)
clust_stats$corrected.rand
clust_stats <- cluster.stats(d = dist(glass),
type, km2.res$cluster)
clust_stats$corrected.rand
table(Glass$Type, km7.res$cluster)
km_stats <- cluster.stats(dist(glass),  km10.res$cluster)
km_stats$dunn
# Load data
data(Glass)
head(Glass)
# Select only numeric variables and scale data
glass <- Glass %>%
select(Na:Fe) %>%
scale()
type <- as.numeric(Glass$Type)
clust_stats <- cluster.stats(d = dist(glass),
type, km10.res$cluster)
clust_stats$corrected.rand
